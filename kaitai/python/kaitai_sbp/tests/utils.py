# Utilities for tests cases for the python version of the Kaitai Struct SBP parser

import kaitai_sbp.table as table_kaitai
from kaitai_sbp.parse_utils import iter_messages as get_next_msg_kaitai, get_flattened_msg, BufferKaitaiStream
from generator.sbpg.targets.common import snake_case, snake_case_keys, decode_json
from kaitaistruct import KaitaiStream, KaitaiStruct
import sys
import sbp.msg as msg_construct
import sbp.table as table_construct
from sbp.sbp2json import iter_messages_buffered as parse_file_construct
from subprocess import Popen, PIPE

SBP_HEADER_LEN = 6
PERL_CMD = ['perl', 'kaitai/perl/bin/sbp2json.pl']


# convert KaitaiStruct object into dict
def dictify(obj, round_floats=False):
    if isinstance(obj, KaitaiStruct):
        return {k: dictify(v, round_floats) for k, v in obj.__dict__.items() if not k.startswith("_")}
    elif isinstance(obj, dict):
        return {k: dictify(v, round_floats) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [dictify(x, round_floats) for x in obj]
    elif round_floats and type(obj) == float:
        return float('{:.10f}'.format(obj)[:11])
    else:
        return obj


# "original" version of sbp2json based entirely upon construct
def get_next_msg_construct(fileobj):
    for msg_type, sender, payload_len, buf, crc_read in parse_file_construct(fileobj):
        msg_buf = buf[SBP_HEADER_LEN:SBP_HEADER_LEN + payload_len]
        msg = msg_construct.SBP(msg_type, sender, payload_len, msg_buf, crc_read)

        if msg_type not in table_construct._SBP_TABLE:
            sys.stderr.write("Skipping unknown message type: {}\n".format(msg_type))
            continue

        msg = table_construct.dispatch(msg)
        yield msg.to_json_dict()


# hybrid version of sbp2json which uses original parser + kaitai struct to
# avoid calling table_construct.dispatch()
def get_next_msg_hybrid1(fileobj):
    stream = BufferKaitaiStream()
    for msg_type, sender, payload_len, buf, crc_read in parse_file_construct(fileobj):

        if msg_type not in table_kaitai.TABLE:
            sys.stderr.write("Skipping unknown message type: {}\n".format(msg_type))
            continue

        stream.set_buffer(bytes(buf))
        obj = table_kaitai.SbpMessage(stream)

        yield get_flattened_msg(obj)


# hybrid version of sbp2json which uses original parser + msg_construct.SBP +
# kaitai struct to avoid calling table_construct.dispatch()
# this version can be used to speed up parsing in existing code based upon the
# construct version
def get_next_msg_hybrid2(fileobj):
    stream = BufferKaitaiStream()
    for msg_type, sender, payload_len, buf, crc_read in parse_file_construct(fileobj):

        if msg_type not in table_kaitai.TABLE:
            sys.stderr.write("Skipping unknown message type: {}\n".format(msg_type))
            continue

        msg_buf = buf[SBP_HEADER_LEN:SBP_HEADER_LEN + payload_len]
        msg = msg_construct.SBP(msg_type, sender, payload_len, msg_buf, crc_read)
        stream.set_buffer(msg.to_binary())
        obj = table_kaitai.SbpMessage(stream)

        yield get_flattened_msg(obj)


def get_next_msg_external(cmd, filename):
    proc = Popen(cmd + [filename], stdout=PIPE)

    for line in proc.stdout:
        yield line


# return number of messages generated by parsing 'filename' with 'fn'
def count_messages(filename, fn, cmd=None):
    num_messages = 0

    args = [open(filename, 'rb')] if cmd is None else [cmd, filename]
    for msg in fn(*args):
        num_messages += 1

    return num_messages


# confirm that all known parsers produce identical output.  The known parsers
# are as follows:
# 1. construct: based completely upon the construct-based python bindings from
#    libsbp
# 2. kaitai: based completely upon the python bindings generated by
#    kaitai-struct-compiler
# 3. hybrid1: use parsing code from construct version + kaitai struct objects
#    (to avoid calling table_construct.dispatch())
# 4. hybrid2: use parsing code from construct version + msg_construct.SBP +
#    kaitai struct objects (to avoid calling table_construct.dispatch())
# 5. perl: based completely upon the perl bindings generated by
#    kaitai-struct-compiler
def compare_parser_outputs(filename):
    num_messages = 0

    file1 = open(filename, 'rb')
    file2 = open(filename, 'rb')
    file3 = open(filename, 'rb')
    file4 = open(filename, 'rb')

    for msg_construct, msg_kaitai, msg_hybrid1, msg_hybrid2, msg_perl in zip(get_next_msg_construct(file1), get_next_msg_kaitai(file2), get_next_msg_hybrid1(file3), get_next_msg_hybrid2(file4), get_next_msg_external(PERL_CMD, filename)):
        msg_construct = snake_case_keys(msg_construct)
        msg_perl = decode_json(msg_perl)

        dict_construct = dictify(msg_construct)
        dict_kaitai = dictify(msg_kaitai)
        dict_hybrid1 = dictify(msg_hybrid1)
        dict_hybrid2 = dictify(msg_hybrid2)

        assert dict_construct == dict_kaitai, "Mismatch:\n{}\nvs\n{}".format(dict_construct, dict_kaitai)
        assert dict_construct == dict_hybrid1, "Mismatch:\n{}\nvs\n{}".format(dict_construct, dict_hybrid1)
        assert dict_construct == dict_hybrid2, "Mismatch:\n{}\nvs\n{}".format(dict_construct, dict_hybrid2)

        # need to round floats due to difference in rounding approaches used
        # by perl and python JSON encoders
        dict_construct = dictify(msg_construct, round_floats=True)
        dict_perl = dictify(msg_perl, round_floats=True)
        assert dict_construct == dict_perl, "Mismatch:\n{}\nvs\n{}".format(dict_construct, dict_perl)
        num_messages += 1
    return num_messages
