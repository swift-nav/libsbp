# This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

import kaitaistruct
from kaitaistruct import KaitaiStruct, KaitaiStream, BytesIO


if getattr(kaitaistruct, 'API_VERSION', (0, 9)) < (0, 9):
    raise Exception("Incompatible Kaitai Struct Python API: 0.9 or later is required, but you have %s" % (kaitaistruct.__version__))

class System(KaitaiStruct):
    def __init__(self, _io, _parent=None, _root=None):
        self._io = _io
        self._parent = _parent
        self._root = _root if _root else self
        self._read()

    def _read(self):
        pass

    class MsgHeartbeat(KaitaiStruct):
        """The heartbeat message is sent periodically to inform the host or other
        attached devices that the system is running. It is used to monitor
        system malfunctions. It also contains status flags that indicate to the
        host the status of the system and whether it is operating correctly.
        Currently, the expected heartbeat interval is 1 sec.
        
        The system error flag is used to indicate that an error has occurred in
        the system. To determine the source of the error, the remaining error
        flags should be inspected.
        """
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.flags = self._io.read_u4le()


    class MsgStatusJournal(KaitaiStruct):
        """The status journal message contains past status reports (see
        MSG_STATUS_REPORT) and functions as a error/event storage for telemetry
        purposes.
        """
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.reporting_system = self._io.read_u2le()
            self.sbp_version = self._io.read_u2le()
            self.total_status_reports = self._io.read_u4le()
            self.sequence_descriptor = self._io.read_u1()
            self.journal = []
            i = 0
            while not self._io.is_eof():
                self.journal.append(System.StatusJournalItem(self._io, self, self._root))
                i += 1



    class MsgInsStatus(KaitaiStruct):
        """The INS status message describes the state of the operation and
        initialization of the inertial navigation system.
        """
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.flags = self._io.read_u4le()


    class MsgGnssTimeOffset(KaitaiStruct):
        """The GNSS time offset message contains the information that is needed to
        translate messages tagged with a local timestamp (e.g. IMU or wheeltick
        messages) to GNSS time for the sender producing this message.
        """
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.weeks = self._io.read_s2le()
            self.milliseconds = self._io.read_s4le()
            self.microseconds = self._io.read_s2le()
            self.flags = self._io.read_u1()


    class MsgCsacTelemetry(KaitaiStruct):
        """The CSAC telemetry message has an implementation defined telemetry
        string from a device. It is not produced or available on general Swift
        Products. It is intended to be a low rate message for status purposes.
        """
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.id = self._io.read_u1()
            self.telemetry = (self._io.read_bytes_full()).decode(u"ascii")


    class MsgPpsTime(KaitaiStruct):
        """The PPS time message contains the value of the sender's local time in
        microseconds at the moment a pulse is detected on the PPS input. This is
        to be used for syncronisation of sensor data sampled with a local
        timestamp (e.g. IMU or wheeltick messages) where GNSS time is unknown to
        the sender.
        
        The local time used to timestamp the PPS pulse must be generated by the
        same clock which is used to timestamp the IMU/wheel sensor data and
        should follow the same roll-over rules.  A separate MSG_PPS_TIME message
        should be sent for each source of sensor data which uses PPS-relative
        timestamping.  The sender ID for each of these MSG_PPS_TIME messages
        should match the sender ID of the respective sensor data.
        """
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.time = self._io.read_u8le()
            self.flags = self._io.read_u1()


    class MsgInsUpdates(KaitaiStruct):
        """The INS update status message contains information about executed and
        rejected INS updates. This message is expected to be extended in the
        future as new types of measurements are being added.
        """
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.tow = self._io.read_u4le()
            self.gnsspos = self._io.read_u1()
            self.gnssvel = self._io.read_u1()
            self.wheelticks = self._io.read_u1()
            self.speed = self._io.read_u1()
            self.nhc = self._io.read_u1()
            self.zerovel = self._io.read_u1()


    class MsgDgnssStatus(KaitaiStruct):
        """This message provides information about the receipt of Differential
        corrections.  It is expected to be sent with each receipt of a complete
        corrections packet.
        """
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.flags = self._io.read_u1()
            self.latency = self._io.read_u2le()
            self.num_signals = self._io.read_u1()
            self.source = (self._io.read_bytes_full()).decode(u"ascii")


    class MsgCsacTelemetryLabels(KaitaiStruct):
        """The CSAC telemetry message provides labels for each member of the string
        produced by MSG_CSAC_TELEMETRY. It should be provided by a device at a
        lower rate than the MSG_CSAC_TELEMETRY.
        """
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.id = self._io.read_u1()
            self.telemetry_labels = (self._io.read_bytes_full()).decode(u"ascii")


    class MsgStartup(KaitaiStruct):
        """The system start-up message is sent once on system start-up. It notifies
        the host or other attached devices that the system has started and is
        now ready to respond to commands or configuration requests.
        """
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.cause = self._io.read_u1()
            self.startup_type = self._io.read_u1()
            self.reserved = self._io.read_u2le()


    class MsgGroupMeta(KaitaiStruct):
        """This leading message lists the time metadata of the Solution Group. It
        also lists the atomic contents (i.e. types of messages included) of the
        Solution Group.
        """
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.group_id = self._io.read_u1()
            self.flags = self._io.read_u1()
            self.n_group_msgs = self._io.read_u1()
            self.group_msgs = []
            i = 0
            while not self._io.is_eof():
                self.group_msgs.append(self._io.read_u2le())
                i += 1



    class MsgSensorAidEvent(KaitaiStruct):
        """This diagnostic message contains state and update status information for
        all sensors that are being used by the fusion engine. This message will
        be generated asynchronously to the solution messages and will be emitted
        anytime a sensor update is being processed.
        """
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.time = self._io.read_u4le()
            self.sensor_type = self._io.read_u1()
            self.sensor_id = self._io.read_u2le()
            self.sensor_state = self._io.read_u1()
            self.n_available_meas = self._io.read_u1()
            self.n_attempted_meas = self._io.read_u1()
            self.n_accepted_meas = self._io.read_u1()
            self.flags = self._io.read_u4le()


    class SubSystemReport(KaitaiStruct):
        """Report the general and specific state of a subsystem.  If the generic
        state is reported as initializing, the specific state should be ignored.
        """
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.component = self._io.read_u2le()
            self.generic = self._io.read_u1()
            self.specific = self._io.read_u1()


    class MsgStatusReport(KaitaiStruct):
        """The status report is sent periodically to inform the host or other
        attached devices that the system is running. It is used to monitor
        system malfunctions. It contains status reports that indicate to the
        host the status of each subsystem and whether it is operating correctly.
        
        Interpretation of the subsystem specific status code is product
        dependent, but if the generic status code is initializing, it should be
        ignored.  Refer to product documentation for details.
        """
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.reporting_system = self._io.read_u2le()
            self.sbp_version = self._io.read_u2le()
            self.sequence = self._io.read_u4le()
            self.uptime = self._io.read_u4le()
            self.status = []
            i = 0
            while not self._io.is_eof():
                self.status.append(System.SubSystemReport(self._io, self, self._root))
                i += 1



    class StatusJournalItem(KaitaiStruct):
        """Reports the uptime and the state of a subsystem via generic and specific
        status codes.  If the generic state is reported as initializing, the
        specific state should be ignored.
        """
        def __init__(self, _io, _parent=None, _root=None):
            self._io = _io
            self._parent = _parent
            self._root = _root if _root else self
            self._read()

        def _read(self):
            self.uptime = self._io.read_u4le()
            self.report = System.SubSystemReport(self._io, self, self._root)



