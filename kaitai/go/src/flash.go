// Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT.

import "github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"

type Flash struct {
	_io *kaitai.Stream
	_root *Flash
	_parent interface{}
}
func NewFlash() *Flash {
	return &Flash{
	}
}

func (this *Flash) Read(io *kaitai.Stream, parent interface{}, root *Flash) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	return err
}

/**
 * This message defines success or failure codes for a variety of flash
 * memory requests from the host to the device. Flash read and write
 * messages, such as MSG_FLASH_READ_REQ, or MSG_FLASH_PROGRAM, may return
 * this message on failure.
 */
type Flash_MsgFlashDone struct {
	Response uint8
	_io *kaitai.Stream
	_root *Flash
	_parent *Sbp_SbpMessage
}
func NewFlash_MsgFlashDone() *Flash_MsgFlashDone {
	return &Flash_MsgFlashDone{
	}
}

func (this *Flash_MsgFlashDone) Read(io *kaitai.Stream, parent *Sbp_SbpMessage, root *Flash) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp1, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Response = tmp1
	return err
}

/**
 * Response flags
 */

/**
 * The flash status message writes to the 8-bit M25 flash status register.
 * The device replies with a MSG_FLASH_DONE message.
 */
type Flash_MsgM25FlashWriteStatus struct {
	Status []uint8
	_io *kaitai.Stream
	_root *Flash
	_parent *Sbp_SbpMessage
}
func NewFlash_MsgM25FlashWriteStatus() *Flash_MsgM25FlashWriteStatus {
	return &Flash_MsgM25FlashWriteStatus{
	}
}

func (this *Flash_MsgM25FlashWriteStatus) Read(io *kaitai.Stream, parent *Sbp_SbpMessage, root *Flash) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0; i < int(1); i++ {
		_ = i
		tmp2, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.Status = append(this.Status, tmp2)
	}
	return err
}

/**
 * Byte to write to the M25 flash status register
 */

/**
 * The flash read message reads a set of addresses of either the STM or M25
 * onboard flash. The device replies with a MSG_FLASH_READ_RESP message
 * containing either the read data on success or a MSG_FLASH_DONE message
 * containing the return code FLASH_INVALID_LEN (2) if the maximum read
 * size is exceeded or FLASH_INVALID_ADDR (3) if the address is outside of
 * the allowed range.
 */
type Flash_MsgFlashReadResp struct {
	Target uint8
	AddrStart []uint8
	AddrLen uint8
	_io *kaitai.Stream
	_root *Flash
	_parent *Sbp_SbpMessage
}
func NewFlash_MsgFlashReadResp() *Flash_MsgFlashReadResp {
	return &Flash_MsgFlashReadResp{
	}
}

func (this *Flash_MsgFlashReadResp) Read(io *kaitai.Stream, parent *Sbp_SbpMessage, root *Flash) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp3, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Target = tmp3
	for i := 0; i < int(3); i++ {
		_ = i
		tmp4, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.AddrStart = append(this.AddrStart, tmp4)
	}
	tmp5, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.AddrLen = tmp5
	return err
}

/**
 * Target flags
 */

/**
 * Starting address offset to read from
 */

/**
 * Length of set of addresses to read, counting up from starting
 * address
 */

/**
 * The flash erase message from the host erases a sector of either the STM
 * or M25 onboard flash memory. The device will reply with a MSG_FLASH_DONE
 * message containing the return code - FLASH_OK (0) on success or
 * FLASH_INVALID_FLASH (1) if the flash specified is invalid.
 */
type Flash_MsgFlashErase struct {
	Target uint8
	SectorNum uint32
	_io *kaitai.Stream
	_root *Flash
	_parent *Sbp_SbpMessage
}
func NewFlash_MsgFlashErase() *Flash_MsgFlashErase {
	return &Flash_MsgFlashErase{
	}
}

func (this *Flash_MsgFlashErase) Read(io *kaitai.Stream, parent *Sbp_SbpMessage, root *Flash) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp6, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Target = tmp6
	tmp7, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.SectorNum = uint32(tmp7)
	return err
}

/**
 * Target flags
 */

/**
 * Flash sector number to erase (0-11 for the STM, 0-15 for the M25)
 */

/**
 * This message reads the device's hard-coded unique ID. The host requests
 * the ID by sending a MSG_STM_UNIQUE_ID_REQ. The device responds with a
 * MSG_STM_UNIQUE_ID_RESP with the 12-byte unique ID in the payload.
 */
type Flash_MsgStmUniqueIdResp struct {
	StmId []uint8
	_io *kaitai.Stream
	_root *Flash
	_parent *Sbp_SbpMessage
}
func NewFlash_MsgStmUniqueIdResp() *Flash_MsgStmUniqueIdResp {
	return &Flash_MsgStmUniqueIdResp{
	}
}

func (this *Flash_MsgStmUniqueIdResp) Read(io *kaitai.Stream, parent *Sbp_SbpMessage, root *Flash) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0; i < int(12); i++ {
		_ = i
		tmp8, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.StmId = append(this.StmId, tmp8)
	}
	return err
}

/**
 * Device unique ID
 */

/**
 * This message reads the device's hard-coded unique ID. The host requests
 * the ID by sending a MSG_STM_UNIQUE_ID_REQ. The device responds with a
 * MSG_STM_UNIQUE_ID_RESP with the 12-byte unique ID in the payload.
 */
type Flash_MsgStmUniqueIdReq struct {
	_io *kaitai.Stream
	_root *Flash
	_parent *Sbp_SbpMessage
}
func NewFlash_MsgStmUniqueIdReq() *Flash_MsgStmUniqueIdReq {
	return &Flash_MsgStmUniqueIdReq{
	}
}

func (this *Flash_MsgStmUniqueIdReq) Read(io *kaitai.Stream, parent *Sbp_SbpMessage, root *Flash) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	return err
}

/**
 * The flash program message programs a set of addresses of either the STM
 * or M25 flash. The device replies with either a MSG_FLASH_DONE message
 * containing the return code FLASH_OK (0) on success, or FLASH_INVALID_LEN
 * (2) if the maximum write size is exceeded. Note that the sector-
 * containing addresses must be erased before addresses can be programmed.
 */
type Flash_MsgFlashProgram struct {
	Target uint8
	AddrStart []uint8
	AddrLen uint8
	Data []uint8
	_io *kaitai.Stream
	_root *Flash
	_parent *Sbp_SbpMessage
}
func NewFlash_MsgFlashProgram() *Flash_MsgFlashProgram {
	return &Flash_MsgFlashProgram{
	}
}

func (this *Flash_MsgFlashProgram) Read(io *kaitai.Stream, parent *Sbp_SbpMessage, root *Flash) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp9, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Target = tmp9
	for i := 0; i < int(3); i++ {
		_ = i
		tmp10, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.AddrStart = append(this.AddrStart, tmp10)
	}
	tmp11, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.AddrLen = tmp11
	for i := 1;; i++ {
		tmp12, err := this._io.EOF()
		if err != nil {
			return err
		}
		if tmp12 {
			break
		}
		tmp13, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.Data = append(this.Data, tmp13)
	}
	return err
}

/**
 * Target flags
 */

/**
 * Starting address offset to program
 */

/**
 * Length of set of addresses to program, counting up from starting
 * address
 */

/**
 * Data to program addresses with, with length N=addr_len
 */

/**
 * The flash read message reads a set of addresses of either the STM or M25
 * onboard flash. The device replies with a MSG_FLASH_READ_RESP message
 * containing either the read data on success or a MSG_FLASH_DONE message
 * containing the return code FLASH_INVALID_LEN (2) if the maximum read
 * size is exceeded or FLASH_INVALID_ADDR (3) if the address is outside of
 * the allowed range.
 */
type Flash_MsgFlashReadReq struct {
	Target uint8
	AddrStart []uint8
	AddrLen uint8
	_io *kaitai.Stream
	_root *Flash
	_parent *Sbp_SbpMessage
}
func NewFlash_MsgFlashReadReq() *Flash_MsgFlashReadReq {
	return &Flash_MsgFlashReadReq{
	}
}

func (this *Flash_MsgFlashReadReq) Read(io *kaitai.Stream, parent *Sbp_SbpMessage, root *Flash) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp14, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Target = tmp14
	for i := 0; i < int(3); i++ {
		_ = i
		tmp15, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.AddrStart = append(this.AddrStart, tmp15)
	}
	tmp16, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.AddrLen = tmp16
	return err
}

/**
 * Target flags
 */

/**
 * Starting address offset to read from
 */

/**
 * Length of set of addresses to read, counting up from starting
 * address
 */

/**
 * The flash unlock message unlocks a sector of the STM flash memory. The
 * device replies with a MSG_FLASH_DONE message.
 */
type Flash_MsgStmFlashUnlockSector struct {
	Sector uint32
	_io *kaitai.Stream
	_root *Flash
	_parent *Sbp_SbpMessage
}
func NewFlash_MsgStmFlashUnlockSector() *Flash_MsgStmFlashUnlockSector {
	return &Flash_MsgStmFlashUnlockSector{
	}
}

func (this *Flash_MsgStmFlashUnlockSector) Read(io *kaitai.Stream, parent *Sbp_SbpMessage, root *Flash) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp17, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Sector = uint32(tmp17)
	return err
}

/**
 * Flash sector number to unlock
 */

/**
 * The flash lock message locks a sector of the STM flash memory. The
 * device replies with a MSG_FLASH_DONE message.
 */
type Flash_MsgStmFlashLockSector struct {
	Sector uint32
	_io *kaitai.Stream
	_root *Flash
	_parent *Sbp_SbpMessage
}
func NewFlash_MsgStmFlashLockSector() *Flash_MsgStmFlashLockSector {
	return &Flash_MsgStmFlashLockSector{
	}
}

func (this *Flash_MsgStmFlashLockSector) Read(io *kaitai.Stream, parent *Sbp_SbpMessage, root *Flash) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp18, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Sector = uint32(tmp18)
	return err
}

/**
 * Flash sector number to lock
 */
