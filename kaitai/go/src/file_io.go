// Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT.

import "github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"

type FileIo struct {
	_io *kaitai.Stream
	_root *FileIo
	_parent interface{}
}
func NewFileIo() *FileIo {
	return &FileIo{
	}
}

func (this *FileIo) Read(io *kaitai.Stream, parent interface{}, root *FileIo) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	return err
}

/**
 * The file write message writes a certain length (up to 255 bytes) of data
 * to a file at a given offset. Returns a copy of the original
 * MSG_FILEIO_WRITE_RESP message to check integrity of the write. The
 * sequence number in the request will be returned in the response. If
 * message is invalid, a followup MSG_PRINT message will print "Invalid
 * fileio write message". A device will only process this message when it
 * is received from sender ID 0x42.
 */
type FileIo_MsgFileioWriteReq struct {
	Sequence uint32
	Offset uint32
	Filename string
	Data []uint8
	_io *kaitai.Stream
	_root *FileIo
	_parent *Sbp_Message
}
func NewFileIo_MsgFileioWriteReq() *FileIo_MsgFileioWriteReq {
	return &FileIo_MsgFileioWriteReq{
	}
}

func (this *FileIo_MsgFileioWriteReq) Read(io *kaitai.Stream, parent *Sbp_Message, root *FileIo) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp1, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Sequence = uint32(tmp1)
	tmp2, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Offset = uint32(tmp2)
	tmp3, err := this._io.ReadBytesFull()
	if err != nil {
		return err
	}
	tmp3 = tmp3
	this.Filename = string(tmp3)
	for i := 1;; i++ {
		tmp4, err := this._io.EOF()
		if err != nil {
			return err
		}
		if tmp4 {
			break
		}
		tmp5, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.Data = append(this.Data, tmp5)
	}
	return err
}

/**
 * Write sequence number
 */

/**
 * Offset into the file at which to start writing in bytes
 */

/**
 * Name of the file to write to
 */

/**
 * Variable-length array of data to write
 */

/**
 * The advice on the optimal configuration for a FileIO transfer.  Newer
 * version of FileIO can support greater throughput by supporting a large
 * window of FileIO data that can be in-flight during read or write
 * operations.
 */
type FileIo_MsgFileioConfigResp struct {
	Sequence uint32
	WindowSize uint32
	BatchSize uint32
	FileioVersion uint32
	_io *kaitai.Stream
	_root *FileIo
	_parent *Sbp_Message
}
func NewFileIo_MsgFileioConfigResp() *FileIo_MsgFileioConfigResp {
	return &FileIo_MsgFileioConfigResp{
	}
}

func (this *FileIo_MsgFileioConfigResp) Read(io *kaitai.Stream, parent *Sbp_Message, root *FileIo) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp6, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Sequence = uint32(tmp6)
	tmp7, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.WindowSize = uint32(tmp7)
	tmp8, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.BatchSize = uint32(tmp8)
	tmp9, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.FileioVersion = uint32(tmp9)
	return err
}

/**
 * Advice sequence number
 */

/**
 * The number of SBP packets in the data in-flight window
 */

/**
 * The number of SBP packets sent in one PDU
 */

/**
 * The version of FileIO that is supported
 */

/**
 * The file remove message deletes a file from the file system. If the
 * message is invalid, a followup MSG_PRINT message will print "Invalid
 * fileio remove message". A device will only process this message when it
 * is received from sender ID 0x42.
 */
type FileIo_MsgFileioRemove struct {
	Filename string
	_io *kaitai.Stream
	_root *FileIo
	_parent *Sbp_Message
}
func NewFileIo_MsgFileioRemove() *FileIo_MsgFileioRemove {
	return &FileIo_MsgFileioRemove{
	}
}

func (this *FileIo_MsgFileioRemove) Read(io *kaitai.Stream, parent *Sbp_Message, root *FileIo) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp10, err := this._io.ReadBytesFull()
	if err != nil {
		return err
	}
	tmp10 = tmp10
	this.Filename = string(tmp10)
	return err
}

/**
 * Name of the file to delete
 */

/**
 * Requests advice on the optimal configuration for a FileIO transfer.
 * Newer version of FileIO can support greater throughput by supporting a
 * large window of FileIO data that can be in-flight during read or write
 * operations.
 */
type FileIo_MsgFileioConfigReq struct {
	Sequence uint32
	_io *kaitai.Stream
	_root *FileIo
	_parent *Sbp_Message
}
func NewFileIo_MsgFileioConfigReq() *FileIo_MsgFileioConfigReq {
	return &FileIo_MsgFileioConfigReq{
	}
}

func (this *FileIo_MsgFileioConfigReq) Read(io *kaitai.Stream, parent *Sbp_Message, root *FileIo) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp11, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Sequence = uint32(tmp11)
	return err
}

/**
 * Advice sequence number
 */

/**
 * The read directory message lists the files in a directory on the
 * device's onboard flash file system.  The offset parameter can be used to
 * skip the first n elements of the file list. Returns a
 * MSG_FILEIO_READ_DIR_RESP message containing the directory listings as a
 * NULL delimited list. The listing is chunked over multiple SBP packets.
 * The sequence number in the request will be returned in the response.  If
 * message is invalid, a followup MSG_PRINT message will print "Invalid
 * fileio read message". A device will only respond to this message when it
 * is received from sender ID 0x42.
 */
type FileIo_MsgFileioReadDirReq struct {
	Sequence uint32
	Offset uint32
	Dirname string
	_io *kaitai.Stream
	_root *FileIo
	_parent *Sbp_Message
}
func NewFileIo_MsgFileioReadDirReq() *FileIo_MsgFileioReadDirReq {
	return &FileIo_MsgFileioReadDirReq{
	}
}

func (this *FileIo_MsgFileioReadDirReq) Read(io *kaitai.Stream, parent *Sbp_Message, root *FileIo) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp12, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Sequence = uint32(tmp12)
	tmp13, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Offset = uint32(tmp13)
	tmp14, err := this._io.ReadBytesFull()
	if err != nil {
		return err
	}
	tmp14 = tmp14
	this.Dirname = string(tmp14)
	return err
}

/**
 * Read sequence number
 */

/**
 * The offset to skip the first n elements of the file list
 */

/**
 * Name of the directory to list
 */

/**
 * The file write message writes a certain length (up to 255 bytes) of data
 * to a file at a given offset. The message is a copy of the original
 * MSG_FILEIO_WRITE_REQ message to check integrity of the write. The
 * sequence number in the response is preserved from the request.
 */
type FileIo_MsgFileioWriteResp struct {
	Sequence uint32
	_io *kaitai.Stream
	_root *FileIo
	_parent *Sbp_Message
}
func NewFileIo_MsgFileioWriteResp() *FileIo_MsgFileioWriteResp {
	return &FileIo_MsgFileioWriteResp{
	}
}

func (this *FileIo_MsgFileioWriteResp) Read(io *kaitai.Stream, parent *Sbp_Message, root *FileIo) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp15, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Sequence = uint32(tmp15)
	return err
}

/**
 * Write sequence number
 */

/**
 * The read directory message lists the files in a directory on the
 * device's onboard flash file system. Message contains the directory
 * listings as a NULL delimited list. The listing is chunked over multiple
 * SBP packets and the end of the list is identified by an packet with no
 * entries. The sequence number in the response is preserved from the
 * request.
 */
type FileIo_MsgFileioReadDirResp struct {
	Sequence uint32
	Contents []uint8
	_io *kaitai.Stream
	_root *FileIo
	_parent *Sbp_Message
}
func NewFileIo_MsgFileioReadDirResp() *FileIo_MsgFileioReadDirResp {
	return &FileIo_MsgFileioReadDirResp{
	}
}

func (this *FileIo_MsgFileioReadDirResp) Read(io *kaitai.Stream, parent *Sbp_Message, root *FileIo) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp16, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Sequence = uint32(tmp16)
	for i := 1;; i++ {
		tmp17, err := this._io.EOF()
		if err != nil {
			return err
		}
		if tmp17 {
			break
		}
		tmp18, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.Contents = append(this.Contents, tmp18)
	}
	return err
}

/**
 * Read sequence number
 */

/**
 * Contents of read directory
 */

/**
 * The file read message reads a certain length (up to 255 bytes) from a
 * given offset into a file, and returns the data in a MSG_FILEIO_READ_RESP
 * message where the message length field indicates how many bytes were
 * successfully read. The sequence number in the request will be returned
 * in the response. If the message is invalid, a followup MSG_PRINT message
 * will print "Invalid fileio read message". A device will only respond to
 * this message when it is received from sender ID 0x42.
 */
type FileIo_MsgFileioReadReq struct {
	Sequence uint32
	Offset uint32
	ChunkSize uint8
	Filename string
	_io *kaitai.Stream
	_root *FileIo
	_parent *Sbp_Message
}
func NewFileIo_MsgFileioReadReq() *FileIo_MsgFileioReadReq {
	return &FileIo_MsgFileioReadReq{
	}
}

func (this *FileIo_MsgFileioReadReq) Read(io *kaitai.Stream, parent *Sbp_Message, root *FileIo) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp19, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Sequence = uint32(tmp19)
	tmp20, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Offset = uint32(tmp20)
	tmp21, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.ChunkSize = tmp21
	tmp22, err := this._io.ReadBytesFull()
	if err != nil {
		return err
	}
	tmp22 = tmp22
	this.Filename = string(tmp22)
	return err
}

/**
 * Read sequence number
 */

/**
 * File offset
 */

/**
 * Chunk size to read
 */

/**
 * Name of the file to read from
 */

/**
 * The file read message reads a certain length (up to 255 bytes) from a
 * given offset into a file, and returns the data in a message where the
 * message length field indicates how many bytes were successfully read.
 * The sequence number in the response is preserved from the request.
 */
type FileIo_MsgFileioReadResp struct {
	Sequence uint32
	Contents []uint8
	_io *kaitai.Stream
	_root *FileIo
	_parent *Sbp_Message
}
func NewFileIo_MsgFileioReadResp() *FileIo_MsgFileioReadResp {
	return &FileIo_MsgFileioReadResp{
	}
}

func (this *FileIo_MsgFileioReadResp) Read(io *kaitai.Stream, parent *Sbp_Message, root *FileIo) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp23, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Sequence = uint32(tmp23)
	for i := 1;; i++ {
		tmp24, err := this._io.EOF()
		if err != nil {
			return err
		}
		if tmp24 {
			break
		}
		tmp25, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.Contents = append(this.Contents, tmp25)
	}
	return err
}

/**
 * Read sequence number
 */

/**
 * Contents of read file
 */
