// Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT.

import "github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"

type Linux struct {
	_io *kaitai.Stream
	_root *Linux
	_parent interface{}
}
func NewLinux() *Linux {
	return &Linux{
	}
}

func (this *Linux) Read(io *kaitai.Stream, parent interface{}, root *Linux) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	return err
}

/**
 * Summaries the socket usage across the system.
 */
type Linux_MsgLinuxSocketUsage struct {
	AvgQueueDepth uint32
	MaxQueueDepth uint32
	SocketStateCounts []uint16
	SocketTypeCounts []uint16
	_io *kaitai.Stream
	_root *Linux
	_parent *Sbp_SbpMessage
}
func NewLinux_MsgLinuxSocketUsage() *Linux_MsgLinuxSocketUsage {
	return &Linux_MsgLinuxSocketUsage{
	}
}

func (this *Linux_MsgLinuxSocketUsage) Read(io *kaitai.Stream, parent *Sbp_SbpMessage, root *Linux) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp1, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.AvgQueueDepth = uint32(tmp1)
	tmp2, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.MaxQueueDepth = uint32(tmp2)
	for i := 0; i < int(16); i++ {
		_ = i
		tmp3, err := this._io.ReadU2le()
		if err != nil {
			return err
		}
		this.SocketStateCounts = append(this.SocketStateCounts, tmp3)
	}
	for i := 0; i < int(16); i++ {
		_ = i
		tmp4, err := this._io.ReadU2le()
		if err != nil {
			return err
		}
		this.SocketTypeCounts = append(this.SocketTypeCounts, tmp4)
	}
	return err
}

/**
 * average socket queue depths across all sockets on the system
 */

/**
 * the max queue depth seen within the reporting period
 */

/**
 * A count for each socket type reported in the `socket_types_reported`
 * field, the first entry corresponds to the first enabled bit in
 * `types_reported`.
 */

/**
 * A count for each socket type reported in the `socket_types_reported`
 * field, the first entry corresponds to the first enabled bit in
 * `types_reported`.
 */

/**
 * This presents a summary of CPU and memory utilization, including a
 * timestamp.
 */
type Linux_MsgLinuxSysState struct {
	MemTotal uint16
	Pcpu uint8
	Pmem uint8
	ProcsStarting uint16
	ProcsStopping uint16
	PidCount uint16
	Time uint32
	Flags uint8
	_io *kaitai.Stream
	_root *Linux
	_parent *Sbp_SbpMessage
}
func NewLinux_MsgLinuxSysState() *Linux_MsgLinuxSysState {
	return &Linux_MsgLinuxSysState{
	}
}

func (this *Linux_MsgLinuxSysState) Read(io *kaitai.Stream, parent *Sbp_SbpMessage, root *Linux) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp5, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.MemTotal = uint16(tmp5)
	tmp6, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Pcpu = tmp6
	tmp7, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Pmem = tmp7
	tmp8, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.ProcsStarting = uint16(tmp8)
	tmp9, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.ProcsStopping = uint16(tmp9)
	tmp10, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.PidCount = uint16(tmp10)
	tmp11, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Time = uint32(tmp11)
	tmp12, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Flags = tmp12
	return err
}

/**
 * total system memory, in MiB
 */

/**
 * percent of CPU used, expressed as a fraction of 256
 */

/**
 * percent of memory used, expressed as a fraction of 256
 */

/**
 * number of processes that started during collection phase
 */

/**
 * number of processes that stopped during collection phase
 */

/**
 * the count of processes on the system
 */

/**
 * timestamp of message, refer to flags field for how to interpret
 */

/**
 * flags
 */

/**
 * Deprecated.
 */
type Linux_MsgLinuxCpuStateDepA struct {
	Index uint8
	Pid uint16
	Pcpu uint8
	Tname string
	Cmdline string
	_io *kaitai.Stream
	_root *Linux
	_parent *Sbp_SbpMessage
}
func NewLinux_MsgLinuxCpuStateDepA() *Linux_MsgLinuxCpuStateDepA {
	return &Linux_MsgLinuxCpuStateDepA{
	}
}

func (this *Linux_MsgLinuxCpuStateDepA) Read(io *kaitai.Stream, parent *Sbp_SbpMessage, root *Linux) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp13, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Index = tmp13
	tmp14, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.Pid = uint16(tmp14)
	tmp15, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Pcpu = tmp15
	tmp16, err := this._io.ReadBytes(int(15))
	if err != nil {
		return err
	}
	tmp16 = tmp16
	this.Tname = string(tmp16)
	tmp17, err := this._io.ReadBytesFull()
	if err != nil {
		return err
	}
	tmp17 = tmp17
	this.Cmdline = string(tmp17)
	return err
}

/**
 * sequence of this status message, values from 0-9
 */

/**
 * the PID of the process
 */

/**
 * percent of cpu used, expressed as a fraction of 256
 */

/**
 * fixed length string representing the thread name
 */

/**
 * the command line (as much as it fits in the remaining packet)
 */

/**
 * This message indicates the process state of the top 10 heaviest
 * consumers of memory on the system, including a timestamp.
 */
type Linux_MsgLinuxMemState struct {
	Index uint8
	Pid uint16
	Pmem uint8
	Time uint32
	Flags uint8
	Tname string
	Cmdline string
	_io *kaitai.Stream
	_root *Linux
	_parent *Sbp_SbpMessage
}
func NewLinux_MsgLinuxMemState() *Linux_MsgLinuxMemState {
	return &Linux_MsgLinuxMemState{
	}
}

func (this *Linux_MsgLinuxMemState) Read(io *kaitai.Stream, parent *Sbp_SbpMessage, root *Linux) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp18, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Index = tmp18
	tmp19, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.Pid = uint16(tmp19)
	tmp20, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Pmem = tmp20
	tmp21, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Time = uint32(tmp21)
	tmp22, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Flags = tmp22
	tmp23, err := this._io.ReadBytes(int(15))
	if err != nil {
		return err
	}
	tmp23 = tmp23
	this.Tname = string(tmp23)
	tmp24, err := this._io.ReadBytesFull()
	if err != nil {
		return err
	}
	tmp24 = tmp24
	this.Cmdline = string(tmp24)
	return err
}

/**
 * sequence of this status message, values from 0-9
 */

/**
 * the PID of the process
 */

/**
 * percent of memory used, expressed as a fraction of 256
 */

/**
 * timestamp of message, refer to flags field for how to interpret
 */

/**
 * flags
 */

/**
 * fixed length string representing the thread name
 */

/**
 * the command line (as much as it fits in the remaining packet)
 */

/**
 * Top 10 list of processes with a large number of open file descriptors.
 */
type Linux_MsgLinuxProcessFdCount struct {
	Index uint8
	Pid uint16
	FdCount uint16
	Cmdline string
	_io *kaitai.Stream
	_root *Linux
	_parent *Sbp_SbpMessage
}
func NewLinux_MsgLinuxProcessFdCount() *Linux_MsgLinuxProcessFdCount {
	return &Linux_MsgLinuxProcessFdCount{
	}
}

func (this *Linux_MsgLinuxProcessFdCount) Read(io *kaitai.Stream, parent *Sbp_SbpMessage, root *Linux) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp25, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Index = tmp25
	tmp26, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.Pid = uint16(tmp26)
	tmp27, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.FdCount = uint16(tmp27)
	tmp28, err := this._io.ReadBytesFull()
	if err != nil {
		return err
	}
	tmp28 = tmp28
	this.Cmdline = string(tmp28)
	return err
}

/**
 * sequence of this status message, values from 0-9
 */

/**
 * the PID of the process in question
 */

/**
 * a count of the number of file descriptors opened by the process
 */

/**
 * the command line of the process in question
 */

/**
 * Deprecated.
 */
type Linux_MsgLinuxMemStateDepA struct {
	Index uint8
	Pid uint16
	Pmem uint8
	Tname string
	Cmdline string
	_io *kaitai.Stream
	_root *Linux
	_parent *Sbp_SbpMessage
}
func NewLinux_MsgLinuxMemStateDepA() *Linux_MsgLinuxMemStateDepA {
	return &Linux_MsgLinuxMemStateDepA{
	}
}

func (this *Linux_MsgLinuxMemStateDepA) Read(io *kaitai.Stream, parent *Sbp_SbpMessage, root *Linux) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp29, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Index = tmp29
	tmp30, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.Pid = uint16(tmp30)
	tmp31, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Pmem = tmp31
	tmp32, err := this._io.ReadBytes(int(15))
	if err != nil {
		return err
	}
	tmp32 = tmp32
	this.Tname = string(tmp32)
	tmp33, err := this._io.ReadBytesFull()
	if err != nil {
		return err
	}
	tmp33 = tmp33
	this.Cmdline = string(tmp33)
	return err
}

/**
 * sequence of this status message, values from 0-9
 */

/**
 * the PID of the process
 */

/**
 * percent of memory used, expressed as a fraction of 256
 */

/**
 * fixed length string representing the thread name
 */

/**
 * the command line (as much as it fits in the remaining packet)
 */

/**
 * Top 10 list of sockets with deep queues.
 */
type Linux_MsgLinuxProcessSocketQueues struct {
	Index uint8
	Pid uint16
	RecvQueued uint16
	SendQueued uint16
	SocketTypes uint16
	SocketStates uint16
	AddressOfLargest string
	Cmdline string
	_io *kaitai.Stream
	_root *Linux
	_parent *Sbp_SbpMessage
}
func NewLinux_MsgLinuxProcessSocketQueues() *Linux_MsgLinuxProcessSocketQueues {
	return &Linux_MsgLinuxProcessSocketQueues{
	}
}

func (this *Linux_MsgLinuxProcessSocketQueues) Read(io *kaitai.Stream, parent *Sbp_SbpMessage, root *Linux) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp34, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Index = tmp34
	tmp35, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.Pid = uint16(tmp35)
	tmp36, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.RecvQueued = uint16(tmp36)
	tmp37, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.SendQueued = uint16(tmp37)
	tmp38, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.SocketTypes = uint16(tmp38)
	tmp39, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.SocketStates = uint16(tmp39)
	tmp40, err := this._io.ReadBytes(int(64))
	if err != nil {
		return err
	}
	tmp40 = tmp40
	this.AddressOfLargest = string(tmp40)
	tmp41, err := this._io.ReadBytesFull()
	if err != nil {
		return err
	}
	tmp41 = tmp41
	this.Cmdline = string(tmp41)
	return err
}

/**
 * sequence of this status message, values from 0-9
 */

/**
 * the PID of the process in question
 */

/**
 * the total amount of receive data queued for this process
 */

/**
 * the total amount of send data queued for this process
 */

/**
 * A bitfield indicating the socket types used: 0x1 (tcp), 0x2 (udp),
 * 0x4 (unix stream), 0x8 (unix dgram), 0x10 (netlink), and 0x8000
 * (unknown)
 */

/**
 * A bitfield indicating the socket states: 0x1 (established), 0x2
 * (syn-sent), 0x4 (syn-recv), 0x8 (fin-wait-1), 0x10 (fin-wait-2),
 * 0x20 (time-wait), 0x40 (closed), 0x80 (close-wait), 0x100 (last-
 * ack), 0x200 (listen), 0x400 (closing), 0x800 (unconnected), and
 * 0x8000 (unknown)
 */

/**
 * Address of the largest queue, remote or local depending on the
 * directionality of the connection.
 */

/**
 * the command line of the process in question
 */

/**
 * Deprecated.
 */
type Linux_MsgLinuxSysStateDepA struct {
	MemTotal uint16
	Pcpu uint8
	Pmem uint8
	ProcsStarting uint16
	ProcsStopping uint16
	PidCount uint16
	_io *kaitai.Stream
	_root *Linux
	_parent *Sbp_SbpMessage
}
func NewLinux_MsgLinuxSysStateDepA() *Linux_MsgLinuxSysStateDepA {
	return &Linux_MsgLinuxSysStateDepA{
	}
}

func (this *Linux_MsgLinuxSysStateDepA) Read(io *kaitai.Stream, parent *Sbp_SbpMessage, root *Linux) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp42, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.MemTotal = uint16(tmp42)
	tmp43, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Pcpu = tmp43
	tmp44, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Pmem = tmp44
	tmp45, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.ProcsStarting = uint16(tmp45)
	tmp46, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.ProcsStopping = uint16(tmp46)
	tmp47, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.PidCount = uint16(tmp47)
	return err
}

/**
 * total system memory
 */

/**
 * percent of total cpu currently utilized
 */

/**
 * percent of total memory currently utilized
 */

/**
 * number of processes that started during collection phase
 */

/**
 * number of processes that stopped during collection phase
 */

/**
 * the count of processes on the system
 */

/**
 * Summary of open file descriptors on the system.
 */
type Linux_MsgLinuxProcessFdSummary struct {
	SysFdCount uint32
	MostOpened string
	_io *kaitai.Stream
	_root *Linux
	_parent *Sbp_SbpMessage
}
func NewLinux_MsgLinuxProcessFdSummary() *Linux_MsgLinuxProcessFdSummary {
	return &Linux_MsgLinuxProcessFdSummary{
	}
}

func (this *Linux_MsgLinuxProcessFdSummary) Read(io *kaitai.Stream, parent *Sbp_SbpMessage, root *Linux) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp48, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.SysFdCount = uint32(tmp48)
	tmp49, err := this._io.ReadBytesFull()
	if err != nil {
		return err
	}
	tmp49 = tmp49
	this.MostOpened = string(tmp49)
	return err
}

/**
 * count of total FDs open on the system
 */

/**
 * A null delimited list of strings which alternates between a string
 * representation of the process count and the file name whose count it
 * being reported.  That is, in C string syntax
 * "32\0/var/log/syslog\012\0/tmp/foo\0" with the end of the list being
 * 2 NULL terminators in a row.
 */

/**
 * This message indicates the process state of the top 10 heaviest
 * consumers of CPU on the system, including a timestamp.
 */
type Linux_MsgLinuxCpuState struct {
	Index uint8
	Pid uint16
	Pcpu uint8
	Time uint32
	Flags uint8
	Tname string
	Cmdline string
	_io *kaitai.Stream
	_root *Linux
	_parent *Sbp_SbpMessage
}
func NewLinux_MsgLinuxCpuState() *Linux_MsgLinuxCpuState {
	return &Linux_MsgLinuxCpuState{
	}
}

func (this *Linux_MsgLinuxCpuState) Read(io *kaitai.Stream, parent *Sbp_SbpMessage, root *Linux) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp50, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Index = tmp50
	tmp51, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.Pid = uint16(tmp51)
	tmp52, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Pcpu = tmp52
	tmp53, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Time = uint32(tmp53)
	tmp54, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Flags = tmp54
	tmp55, err := this._io.ReadBytes(int(15))
	if err != nil {
		return err
	}
	tmp55 = tmp55
	this.Tname = string(tmp55)
	tmp56, err := this._io.ReadBytesFull()
	if err != nil {
		return err
	}
	tmp56 = tmp56
	this.Cmdline = string(tmp56)
	return err
}

/**
 * sequence of this status message, values from 0-9
 */

/**
 * the PID of the process
 */

/**
 * percent of CPU used, expressed as a fraction of 256
 */

/**
 * timestamp of message, refer to flags field for how to interpret
 */

/**
 * flags
 */

/**
 * fixed length string representing the thread name
 */

/**
 * the command line (as much as it fits in the remaining packet)
 */

/**
 * Top 10 list of processes with high socket counts.
 */
type Linux_MsgLinuxProcessSocketCounts struct {
	Index uint8
	Pid uint16
	SocketCount uint16
	SocketTypes uint16
	SocketStates uint16
	Cmdline string
	_io *kaitai.Stream
	_root *Linux
	_parent *Sbp_SbpMessage
}
func NewLinux_MsgLinuxProcessSocketCounts() *Linux_MsgLinuxProcessSocketCounts {
	return &Linux_MsgLinuxProcessSocketCounts{
	}
}

func (this *Linux_MsgLinuxProcessSocketCounts) Read(io *kaitai.Stream, parent *Sbp_SbpMessage, root *Linux) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp57, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Index = tmp57
	tmp58, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.Pid = uint16(tmp58)
	tmp59, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.SocketCount = uint16(tmp59)
	tmp60, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.SocketTypes = uint16(tmp60)
	tmp61, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.SocketStates = uint16(tmp61)
	tmp62, err := this._io.ReadBytesFull()
	if err != nil {
		return err
	}
	tmp62 = tmp62
	this.Cmdline = string(tmp62)
	return err
}

/**
 * sequence of this status message, values from 0-9
 */

/**
 * the PID of the process in question
 */

/**
 * the number of sockets the process is using
 */

/**
 * A bitfield indicating the socket types used: 0x1 (tcp), 0x2 (udp),
 * 0x4 (unix stream), 0x8 (unix dgram), 0x10 (netlink), and 0x8000
 * (unknown)
 */

/**
 * A bitfield indicating the socket states: 0x1 (established), 0x2
 * (syn-sent), 0x4 (syn-recv), 0x8 (fin-wait-1), 0x10 (fin-wait-2),
 * 0x20 (time-wait), 0x40 (closed), 0x80 (close-wait), 0x100 (last-
 * ack), 0x200 (listen), 0x400 (closing), 0x800 (unconnected), and
 * 0x8000 (unknown)
 */

/**
 * the command line of the process in question
 */
