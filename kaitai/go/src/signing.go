// Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT.

import "github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"

type Signing struct {
	_io *kaitai.Stream
	_root *Signing
	_parent interface{}
}
func NewSigning() *Signing {
	return &Signing{
	}
}

func (this *Signing) Read(io *kaitai.Stream, parent interface{}, root *Signing) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	return err
}
type Signing_MsgEd25519SignatureDepB struct {
	StreamCounter uint8
	OnDemandCounter uint8
	Signature []uint8
	Fingerprint []uint8
	SignedMessages []uint32
	_io *kaitai.Stream
	_root *Signing
	_parent *Sbp_Message
}
func NewSigning_MsgEd25519SignatureDepB() *Signing_MsgEd25519SignatureDepB {
	return &Signing_MsgEd25519SignatureDepB{
	}
}

func (this *Signing_MsgEd25519SignatureDepB) Read(io *kaitai.Stream, parent *Sbp_Message, root *Signing) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp1, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.StreamCounter = tmp1
	tmp2, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.OnDemandCounter = tmp2
	for i := 0; i < int(64); i++ {
		_ = i
		tmp3, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.Signature = append(this.Signature, tmp3)
	}
	for i := 0; i < int(20); i++ {
		_ = i
		tmp4, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.Fingerprint = append(this.Fingerprint, tmp4)
	}
	for i := 1;; i++ {
		tmp5, err := this._io.EOF()
		if err != nil {
			return err
		}
		if tmp5 {
			break
		}
		tmp6, err := this._io.ReadU4le()
		if err != nil {
			return err
		}
		this.SignedMessages = append(this.SignedMessages, tmp6)
	}
	return err
}

/**
 * Signature message counter. Zero indexed and incremented with each
 * signature message.  The counter will not increment if this message
 * was in response to an on demand request.  The counter will roll over
 * after 256 messages. Upon connection, the value of the counter may
 * not initially be zero.
 */

/**
 * On demand message counter. Zero indexed and incremented with each
 * signature message sent in response to an on demand message. The
 * counter will roll over after 256 messages.  Upon connection, the
 * value of the counter may not initially be zero.
 */

/**
 * ED25519 signature for messages.
 */

/**
 * SHA-1 fingerprint of the associated certificate.
 */

/**
 * CRCs of signed messages.
 */
type Signing_MsgEd25519CertificateDep struct {
	NMsg uint8
	Fingerprint []uint8
	CertificateBytes []uint8
	_io *kaitai.Stream
	_root *Signing
	_parent *Sbp_Message
}
func NewSigning_MsgEd25519CertificateDep() *Signing_MsgEd25519CertificateDep {
	return &Signing_MsgEd25519CertificateDep{
	}
}

func (this *Signing_MsgEd25519CertificateDep) Read(io *kaitai.Stream, parent *Sbp_Message, root *Signing) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp7, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.NMsg = tmp7
	for i := 0; i < int(20); i++ {
		_ = i
		tmp8, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.Fingerprint = append(this.Fingerprint, tmp8)
	}
	for i := 1;; i++ {
		tmp9, err := this._io.EOF()
		if err != nil {
			return err
		}
		if tmp9 {
			break
		}
		tmp10, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.CertificateBytes = append(this.CertificateBytes, tmp10)
	}
	return err
}

/**
 * Total number messages that make up the certificate. First nibble is
 * the size of the sequence (n), second nibble is the zero-indexed
 * counter (ith packet of n)
 */

/**
 * SHA-1 fingerprint of the associated certificate.
 */

/**
 * ED25519 certificate bytes.
 */
type Signing_UtcTime struct {
	Year uint16
	Month uint8
	Day uint8
	Hours uint8
	Minutes uint8
	Seconds uint8
	Ns uint32
	_io *kaitai.Stream
	_root *Signing
	_parent *Signing_MsgCertificateChain
}
func NewSigning_UtcTime() *Signing_UtcTime {
	return &Signing_UtcTime{
	}
}

func (this *Signing_UtcTime) Read(io *kaitai.Stream, parent *Signing_MsgCertificateChain, root *Signing) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp11, err := this._io.ReadU2le()
	if err != nil {
		return err
	}
	this.Year = uint16(tmp11)
	tmp12, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Month = tmp12
	tmp13, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Day = tmp13
	tmp14, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Hours = tmp14
	tmp15, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Minutes = tmp15
	tmp16, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Seconds = tmp16
	tmp17, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Ns = uint32(tmp17)
	return err
}

/**
 * Year
 */

/**
 * Month (range 1 .. 12)
 */

/**
 * days in the month (range 1-31)
 */

/**
 * hours of day (range 0-23)
 */

/**
 * minutes of hour (range 0-59)
 */

/**
 * seconds of minute (range 0-60) rounded down
 */

/**
 * nanoseconds of second (range 0-999999999)
 */
type Signing_MsgEd25519SignatureDepA struct {
	Signature []uint8
	Fingerprint []uint8
	SignedMessages []uint32
	_io *kaitai.Stream
	_root *Signing
	_parent *Sbp_Message
}
func NewSigning_MsgEd25519SignatureDepA() *Signing_MsgEd25519SignatureDepA {
	return &Signing_MsgEd25519SignatureDepA{
	}
}

func (this *Signing_MsgEd25519SignatureDepA) Read(io *kaitai.Stream, parent *Sbp_Message, root *Signing) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0; i < int(64); i++ {
		_ = i
		tmp18, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.Signature = append(this.Signature, tmp18)
	}
	for i := 0; i < int(20); i++ {
		_ = i
		tmp19, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.Fingerprint = append(this.Fingerprint, tmp19)
	}
	for i := 1;; i++ {
		tmp20, err := this._io.EOF()
		if err != nil {
			return err
		}
		if tmp20 {
			break
		}
		tmp21, err := this._io.ReadU4le()
		if err != nil {
			return err
		}
		this.SignedMessages = append(this.SignedMessages, tmp21)
	}
	return err
}

/**
 * ED25519 signature for messages.
 */

/**
 * SHA-1 fingerprint of the associated certificate.
 */

/**
 * CRCs of signed messages.
 */
type Signing_MsgCertificateChain struct {
	RootCertificate []uint8
	IntermediateCertificate []uint8
	CorrectionsCertificate []uint8
	Expiration *Signing_UtcTime
	Signature []uint8
	_io *kaitai.Stream
	_root *Signing
	_parent *Sbp_Message
}
func NewSigning_MsgCertificateChain() *Signing_MsgCertificateChain {
	return &Signing_MsgCertificateChain{
	}
}

func (this *Signing_MsgCertificateChain) Read(io *kaitai.Stream, parent *Sbp_Message, root *Signing) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	for i := 0; i < int(20); i++ {
		_ = i
		tmp22, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.RootCertificate = append(this.RootCertificate, tmp22)
	}
	for i := 0; i < int(20); i++ {
		_ = i
		tmp23, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.IntermediateCertificate = append(this.IntermediateCertificate, tmp23)
	}
	for i := 0; i < int(20); i++ {
		_ = i
		tmp24, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.CorrectionsCertificate = append(this.CorrectionsCertificate, tmp24)
	}
	tmp25 := NewSigning_UtcTime()
	err = tmp25.Read(this._io, this, this._root)
	if err != nil {
		return err
	}
	this.Expiration = tmp25
	for i := 0; i < int(64); i++ {
		_ = i
		tmp26, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.Signature = append(this.Signature, tmp26)
	}
	return err
}

/**
 * SHA-1 fingerprint of the root certificate
 */

/**
 * SHA-1 fingerprint of the intermediate certificate
 */

/**
 * SHA-1 fingerprint of the corrections certificate
 */

/**
 * The certificate chain comprised of three fingerprints: root
 * certificate, intermediate certificate and corrections certificate.
 */

/**
 * An ECDSA signature (created by the root certificate) over the
 * concatenation of the SBP payload bytes preceding this field. That
 * is, the concatenation of `root_certificate`,
 * `intermediate_certificate`, `corrections_certificate` and
 * `expiration`.  This certificate chain (allow list) can also be
 * validated by fetching it from `http(s)://certs.swiftnav.com/chain`.
 */

/**
 * A DER encoded x.509 ECDSA-256 certificate (using curve secp256r1).
 */
type Signing_MsgEcdsaCertificate struct {
	NMsg uint8
	CertificateId []uint8
	Flags uint8
	CertificateBytes []uint8
	_io *kaitai.Stream
	_root *Signing
	_parent *Sbp_Message
}
func NewSigning_MsgEcdsaCertificate() *Signing_MsgEcdsaCertificate {
	return &Signing_MsgEcdsaCertificate{
	}
}

func (this *Signing_MsgEcdsaCertificate) Read(io *kaitai.Stream, parent *Sbp_Message, root *Signing) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp27, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.NMsg = tmp27
	for i := 0; i < int(4); i++ {
		_ = i
		tmp28, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.CertificateId = append(this.CertificateId, tmp28)
	}
	tmp29, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Flags = tmp29
	for i := 1;; i++ {
		tmp30, err := this._io.EOF()
		if err != nil {
			return err
		}
		if tmp30 {
			break
		}
		tmp31, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.CertificateBytes = append(this.CertificateBytes, tmp31)
	}
	return err
}

/**
 * Total number messages that make up the certificate. The first nibble
 * (mask 0xF0 or left shifted by 4 bits) is the size of the sequence
 * (n), second nibble (mask 0x0F) is the zero-indexed counter (ith
 * packet of n).
 */

/**
 * The last 4 bytes of the certificate's SHA-1 fingerprint
 */

/**
 * DER encoded x.509 ECDSA certificate bytes
 */

/**
 * An ECDSA-256 signature using SHA-256 as the message digest algorithm.
 */
type Signing_MsgEcdsaSignature struct {
	Flags uint8
	StreamCounter uint8
	OnDemandCounter uint8
	CertificateId []uint8
	Signature []uint8
	SignedMessages []uint8
	_io *kaitai.Stream
	_root *Signing
	_parent *Sbp_Message
}
func NewSigning_MsgEcdsaSignature() *Signing_MsgEcdsaSignature {
	return &Signing_MsgEcdsaSignature{
	}
}

func (this *Signing_MsgEcdsaSignature) Read(io *kaitai.Stream, parent *Sbp_Message, root *Signing) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp32, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.Flags = tmp32
	tmp33, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.StreamCounter = tmp33
	tmp34, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.OnDemandCounter = tmp34
	for i := 0; i < int(4); i++ {
		_ = i
		tmp35, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.CertificateId = append(this.CertificateId, tmp35)
	}
	for i := 0; i < int(64); i++ {
		_ = i
		tmp36, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.Signature = append(this.Signature, tmp36)
	}
	for i := 1;; i++ {
		tmp37, err := this._io.EOF()
		if err != nil {
			return err
		}
		if tmp37 {
			break
		}
		tmp38, err := this._io.ReadU1()
		if err != nil {
			return err
		}
		this.SignedMessages = append(this.SignedMessages, tmp38)
	}
	return err
}

/**
 * Describes the format of the `signed\_messages` field below.
 */

/**
 * Signature message counter. Zero indexed and incremented with each
 * signature message.  The counter will not increment if this message
 * was in response to an on demand request.  The counter will roll over
 * after 256 messages. Upon connection, the value of the counter may
 * not initially be zero.
 */

/**
 * On demand message counter. Zero indexed and incremented with each
 * signature message sent in response to an on demand message. The
 * counter will roll over after 256 messages.  Upon connection, the
 * value of the counter may not initially be zero.
 */

/**
 * The last 4 bytes of the certificate's SHA-1 fingerprint
 */

/**
 * ECDSA signature for the messages using SHA-256 as the digest
 * algorithm.
 */

/**
 * CRCs of the messages covered by this signature.  For Skylark, which
 * delivers SBP messages wrapped in Swift's proprietary RTCM message,
 * these are the 24-bit CRCs from the RTCM message framing. For SBP
 * only streams, this will be 16-bit CRCs from the SBP framing.  See
 * the `flags` field to determine the type of CRCs covered.
 */
