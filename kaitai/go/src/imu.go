// Code generated by kaitai-struct-compiler from a .ksy source file. DO NOT EDIT.

import "github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"

type Imu struct {
	_io *kaitai.Stream
	_root *Imu
	_parent interface{}
}
func NewImu() *Imu {
	return &Imu{
	}
}

func (this *Imu) Read(io *kaitai.Stream, parent interface{}, root *Imu) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	return err
}

/**
 * Raw data from the Inertial Measurement Unit, containing accelerometer
 * and gyroscope readings. The sense of the measurements are to be aligned
 * with the indications on the device itself. Measurement units, which are
 * specific to the device hardware and settings, are communicated via the
 * MSG_IMU_AUX message. If using "time since startup" time tags, the
 * receiving end will expect a `MSG_GNSS_TIME_OFFSET` when a PVT fix
 * becomes available to synchronise IMU measurements with GNSS. The
 * timestamp must wrap around to zero when reaching one week (604800
 * seconds).
 * 
 * The time-tagging mode should not change throughout a run.
 */
type Imu_MsgImuRaw struct {
	Tow uint32
	TowF uint8
	AccX int16
	AccY int16
	AccZ int16
	GyrX int16
	GyrY int16
	GyrZ int16
	_io *kaitai.Stream
	_root *Imu
	_parent *Sbp_Message
}
func NewImu_MsgImuRaw() *Imu_MsgImuRaw {
	return &Imu_MsgImuRaw{
	}
}

func (this *Imu_MsgImuRaw) Read(io *kaitai.Stream, parent *Sbp_Message, root *Imu) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp1, err := this._io.ReadU4le()
	if err != nil {
		return err
	}
	this.Tow = uint32(tmp1)
	tmp2, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.TowF = tmp2
	tmp3, err := this._io.ReadS2le()
	if err != nil {
		return err
	}
	this.AccX = int16(tmp3)
	tmp4, err := this._io.ReadS2le()
	if err != nil {
		return err
	}
	this.AccY = int16(tmp4)
	tmp5, err := this._io.ReadS2le()
	if err != nil {
		return err
	}
	this.AccZ = int16(tmp5)
	tmp6, err := this._io.ReadS2le()
	if err != nil {
		return err
	}
	this.GyrX = int16(tmp6)
	tmp7, err := this._io.ReadS2le()
	if err != nil {
		return err
	}
	this.GyrY = int16(tmp7)
	tmp8, err := this._io.ReadS2le()
	if err != nil {
		return err
	}
	this.GyrZ = int16(tmp8)
	return err
}

/**
 * Milliseconds since reference epoch and time status.
 */

/**
 * Milliseconds since reference epoch, fractional part
 */

/**
 * Acceleration in the IMU frame X axis
 */

/**
 * Acceleration in the IMU frame Y axis
 */

/**
 * Acceleration in the IMU frame Z axis
 */

/**
 * Angular rate around IMU frame X axis
 */

/**
 * Angular rate around IMU frame Y axis
 */

/**
 * Angular rate around IMU frame Z axis
 */

/**
 * Auxiliary data specific to a particular IMU. The `imu_type` field will
 * always be consistent but the rest of the payload is device specific and
 * depends on the value of `imu_type`.
 */
type Imu_MsgImuAux struct {
	ImuType uint8
	Temp int16
	ImuConf uint8
	_io *kaitai.Stream
	_root *Imu
	_parent *Sbp_Message
}
func NewImu_MsgImuAux() *Imu_MsgImuAux {
	return &Imu_MsgImuAux{
	}
}

func (this *Imu_MsgImuAux) Read(io *kaitai.Stream, parent *Sbp_Message, root *Imu) (err error) {
	this._io = io
	this._parent = parent
	this._root = root

	tmp9, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.ImuType = tmp9
	tmp10, err := this._io.ReadS2le()
	if err != nil {
		return err
	}
	this.Temp = int16(tmp10)
	tmp11, err := this._io.ReadU1()
	if err != nil {
		return err
	}
	this.ImuConf = tmp11
	return err
}

/**
 * IMU type
 */

/**
 * Raw IMU temperature
 */

/**
 * IMU configuration
 */
