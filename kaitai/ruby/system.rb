# This is a generated file! Please edit source .ksy file and use kaitai-struct-compiler to rebuild

require 'kaitai/struct/struct'

unless Gem::Version.new(Kaitai::Struct::VERSION) >= Gem::Version.new('0.9')
  raise "Incompatible Kaitai Struct Ruby API: 0.9 or later is required, but you have #{Kaitai::Struct::VERSION}"
end

class System < Kaitai::Struct::Struct
  def initialize(_io, _parent = nil, _root = self)
    super(_io, _parent, _root)
    _read
  end

  def _read
    self
  end

  ##
  # The heartbeat message is sent periodically to inform the host or other
  # attached devices that the system is running. It is used to monitor
  # system malfunctions. It also contains status flags that indicate to the
  # host the status of the system and whether it is operating correctly.
  # Currently, the expected heartbeat interval is 1 sec.
  # 
  # The system error flag is used to indicate that an error has occurred in
  # the system. To determine the source of the error, the remaining error
  # flags should be inspected.
  class MsgHeartbeat < Kaitai::Struct::Struct
    def initialize(_io, _parent = nil, _root = self)
      super(_io, _parent, _root)
      _read
    end

    def _read
      @flags = @_io.read_u4le
      self
    end

    ##
    # Status flags
    attr_reader :flags
  end

  ##
  # The status journal message contains past status reports (see
  # MSG_STATUS_REPORT) and functions as a error/event storage for telemetry
  # purposes.
  class MsgStatusJournal < Kaitai::Struct::Struct
    def initialize(_io, _parent = nil, _root = self)
      super(_io, _parent, _root)
      _read
    end

    def _read
      @reporting_system = @_io.read_u2le
      @sbp_version = @_io.read_u2le
      @total_status_reports = @_io.read_u4le
      @sequence_descriptor = @_io.read_u1
      @journal = []
      i = 0
      while not @_io.eof?
        @journal << StatusJournalItem.new(@_io, self, @_root)
        i += 1
      end
      self
    end

    ##
    # Identity of reporting system
    attr_reader :reporting_system

    ##
    # SBP protocol version
    attr_reader :sbp_version

    ##
    # Total number of status reports sent since system startup
    attr_reader :total_status_reports

    ##
    # Index and number of messages in this sequence. First nibble is the
    # size of the sequence (n), second nibble is the zero-indexed counter
    # (ith packet of n)
    attr_reader :sequence_descriptor

    ##
    # Status journal
    attr_reader :journal
  end

  ##
  # The INS status message describes the state of the operation and
  # initialization of the inertial navigation system.
  class MsgInsStatus < Kaitai::Struct::Struct
    def initialize(_io, _parent = nil, _root = self)
      super(_io, _parent, _root)
      _read
    end

    def _read
      @flags = @_io.read_u4le
      self
    end

    ##
    # Status flags
    attr_reader :flags
  end

  ##
  # The GNSS time offset message contains the information that is needed to
  # translate messages tagged with a local timestamp (e.g. IMU or wheeltick
  # messages) to GNSS time for the sender producing this message.
  class MsgGnssTimeOffset < Kaitai::Struct::Struct
    def initialize(_io, _parent = nil, _root = self)
      super(_io, _parent, _root)
      _read
    end

    def _read
      @weeks = @_io.read_s2le
      @milliseconds = @_io.read_s4le
      @microseconds = @_io.read_s2le
      @flags = @_io.read_u1
      self
    end

    ##
    # Weeks portion of the time offset
    attr_reader :weeks

    ##
    # Milliseconds portion of the time offset
    attr_reader :milliseconds

    ##
    # Microseconds portion of the time offset
    attr_reader :microseconds

    ##
    # Status flags (reserved)
    attr_reader :flags
  end

  ##
  # The CSAC telemetry message has an implementation defined telemetry
  # string from a device. It is not produced or available on general Swift
  # Products. It is intended to be a low rate message for status purposes.
  class MsgCsacTelemetry < Kaitai::Struct::Struct
    def initialize(_io, _parent = nil, _root = self)
      super(_io, _parent, _root)
      _read
    end

    def _read
      @id = @_io.read_u1
      @telemetry = (@_io.read_bytes_full).force_encoding("ascii")
      self
    end

    ##
    # Index representing the type of telemetry in use.  It is
    # implementation defined.
    attr_reader :id

    ##
    # Comma separated list of values as defined by the index
    attr_reader :telemetry
  end

  ##
  # The PPS time message contains the value of the sender's local time in
  # microseconds at the moment a pulse is detected on the PPS input. This is
  # to be used for syncronisation of sensor data sampled with a local
  # timestamp (e.g. IMU or wheeltick messages) where GNSS time is unknown to
  # the sender.
  # 
  # The local time used to timestamp the PPS pulse must be generated by the
  # same clock which is used to timestamp the IMU/wheel sensor data and
  # should follow the same roll-over rules.  A separate MSG_PPS_TIME message
  # should be sent for each source of sensor data which uses PPS-relative
  # timestamping.  The sender ID for each of these MSG_PPS_TIME messages
  # should match the sender ID of the respective sensor data.
  class MsgPpsTime < Kaitai::Struct::Struct
    def initialize(_io, _parent = nil, _root = self)
      super(_io, _parent, _root)
      _read
    end

    def _read
      @time = @_io.read_u8le
      @flags = @_io.read_u1
      self
    end

    ##
    # Local time in microseconds
    attr_reader :time

    ##
    # Status flags
    attr_reader :flags
  end

  ##
  # The INS update status message contains information about executed and
  # rejected INS updates. This message is expected to be extended in the
  # future as new types of measurements are being added.
  class MsgInsUpdates < Kaitai::Struct::Struct
    def initialize(_io, _parent = nil, _root = self)
      super(_io, _parent, _root)
      _read
    end

    def _read
      @tow = @_io.read_u4le
      @gnsspos = @_io.read_u1
      @gnssvel = @_io.read_u1
      @wheelticks = @_io.read_u1
      @speed = @_io.read_u1
      @nhc = @_io.read_u1
      @zerovel = @_io.read_u1
      self
    end

    ##
    # GPS Time of Week
    attr_reader :tow

    ##
    # GNSS position update status flags
    attr_reader :gnsspos

    ##
    # GNSS velocity update status flags
    attr_reader :gnssvel

    ##
    # Wheelticks update status flags
    attr_reader :wheelticks

    ##
    # Wheelticks update status flags
    attr_reader :speed

    ##
    # NHC update status flags
    attr_reader :nhc

    ##
    # Zero velocity update status flags
    attr_reader :zerovel
  end

  ##
  # This message provides information about the receipt of Differential
  # corrections.  It is expected to be sent with each receipt of a complete
  # corrections packet.
  class MsgDgnssStatus < Kaitai::Struct::Struct
    def initialize(_io, _parent = nil, _root = self)
      super(_io, _parent, _root)
      _read
    end

    def _read
      @flags = @_io.read_u1
      @latency = @_io.read_u2le
      @num_signals = @_io.read_u1
      @source = (@_io.read_bytes_full).force_encoding("ascii")
      self
    end

    ##
    # Status flags
    attr_reader :flags

    ##
    # Latency of observation receipt
    attr_reader :latency

    ##
    # Number of signals from base station
    attr_reader :num_signals

    ##
    # Corrections source string
    attr_reader :source
  end

  ##
  # The CSAC telemetry message provides labels for each member of the string
  # produced by MSG_CSAC_TELEMETRY. It should be provided by a device at a
  # lower rate than the MSG_CSAC_TELEMETRY.
  class MsgCsacTelemetryLabels < Kaitai::Struct::Struct
    def initialize(_io, _parent = nil, _root = self)
      super(_io, _parent, _root)
      _read
    end

    def _read
      @id = @_io.read_u1
      @telemetry_labels = (@_io.read_bytes_full).force_encoding("ascii")
      self
    end

    ##
    # Index representing the type of telemetry in use.  It is
    # implementation defined.
    attr_reader :id

    ##
    # Comma separated list of telemetry field values
    attr_reader :telemetry_labels
  end

  ##
  # The system start-up message is sent once on system start-up. It notifies
  # the host or other attached devices that the system has started and is
  # now ready to respond to commands or configuration requests.
  class MsgStartup < Kaitai::Struct::Struct
    def initialize(_io, _parent = nil, _root = self)
      super(_io, _parent, _root)
      _read
    end

    def _read
      @cause = @_io.read_u1
      @startup_type = @_io.read_u1
      @reserved = @_io.read_u2le
      self
    end

    ##
    # Cause of startup
    attr_reader :cause

    ##
    # Startup type
    attr_reader :startup_type

    ##
    # Reserved
    attr_reader :reserved
  end

  ##
  # This leading message lists the time metadata of the Solution Group. It
  # also lists the atomic contents (i.e. types of messages included) of the
  # Solution Group.
  class MsgGroupMeta < Kaitai::Struct::Struct
    def initialize(_io, _parent = nil, _root = self)
      super(_io, _parent, _root)
      _read
    end

    def _read
      @group_id = @_io.read_u1
      @flags = @_io.read_u1
      @n_group_msgs = @_io.read_u1
      @group_msgs = []
      i = 0
      while not @_io.eof?
        @group_msgs << @_io.read_u2le
        i += 1
      end
      self
    end

    ##
    # Id of the Msgs Group, 0 is Unknown, 1 is Bestpos, 2 is Gnss
    attr_reader :group_id

    ##
    # Status flags (reserved)
    attr_reader :flags

    ##
    # Size of list group_msgs
    attr_reader :n_group_msgs

    ##
    # An in-order list of message types included in the Solution Group,
    # including GROUP_META itself
    attr_reader :group_msgs
  end

  ##
  # This diagnostic message contains state and update status information for
  # all sensors that are being used by the fusion engine. This message will
  # be generated asynchronously to the solution messages and will be emitted
  # anytime a sensor update is being processed.
  class MsgSensorAidEvent < Kaitai::Struct::Struct
    def initialize(_io, _parent = nil, _root = self)
      super(_io, _parent, _root)
      _read
    end

    def _read
      @time = @_io.read_u4le
      @sensor_type = @_io.read_u1
      @sensor_id = @_io.read_u2le
      @sensor_state = @_io.read_u1
      @n_available_meas = @_io.read_u1
      @n_attempted_meas = @_io.read_u1
      @n_accepted_meas = @_io.read_u1
      @flags = @_io.read_u4le
      self
    end

    ##
    # Update timestamp in milliseconds.
    attr_reader :time

    ##
    # Sensor type
    attr_reader :sensor_type

    ##
    # Sensor identifier
    attr_reader :sensor_id

    ##
    # Reserved for future use
    attr_reader :sensor_state

    ##
    # Number of available measurements in this epoch
    attr_reader :n_available_meas

    ##
    # Number of attempted measurements in this epoch
    attr_reader :n_attempted_meas

    ##
    # Number of accepted measurements in this epoch
    attr_reader :n_accepted_meas

    ##
    # Reserved for future use
    attr_reader :flags
  end

  ##
  # Report the general and specific state of a subsystem.  If the generic
  # state is reported as initializing, the specific state should be ignored.
  class SubSystemReport < Kaitai::Struct::Struct
    def initialize(_io, _parent = nil, _root = self)
      super(_io, _parent, _root)
      _read
    end

    def _read
      @component = @_io.read_u2le
      @generic = @_io.read_u1
      @specific = @_io.read_u1
      self
    end

    ##
    # Identity of reporting subsystem
    attr_reader :component

    ##
    # Generic form status report
    attr_reader :generic

    ##
    # Subsystem specific status code
    attr_reader :specific
  end

  ##
  # The status report is sent periodically to inform the host or other
  # attached devices that the system is running. It is used to monitor
  # system malfunctions. It contains status reports that indicate to the
  # host the status of each subsystem and whether it is operating correctly.
  # 
  # Interpretation of the subsystem specific status code is product
  # dependent, but if the generic status code is initializing, it should be
  # ignored.  Refer to product documentation for details.
  class MsgStatusReport < Kaitai::Struct::Struct
    def initialize(_io, _parent = nil, _root = self)
      super(_io, _parent, _root)
      _read
    end

    def _read
      @reporting_system = @_io.read_u2le
      @sbp_version = @_io.read_u2le
      @sequence = @_io.read_u4le
      @uptime = @_io.read_u4le
      @status = []
      i = 0
      while not @_io.eof?
        @status << SubSystemReport.new(@_io, self, @_root)
        i += 1
      end
      self
    end

    ##
    # Identity of reporting system
    attr_reader :reporting_system

    ##
    # SBP protocol version
    attr_reader :sbp_version

    ##
    # Increments on each status report sent
    attr_reader :sequence

    ##
    # Number of seconds since system start-up
    attr_reader :uptime

    ##
    # Reported status of individual subsystems
    attr_reader :status
  end

  ##
  # Reports the uptime and the state of a subsystem via generic and specific
  # status codes.  If the generic state is reported as initializing, the
  # specific state should be ignored.
  class StatusJournalItem < Kaitai::Struct::Struct
    def initialize(_io, _parent = nil, _root = self)
      super(_io, _parent, _root)
      _read
    end

    def _read
      @uptime = @_io.read_u4le
      @report = SubSystemReport.new(@_io, self, @_root)
      self
    end

    ##
    # Milliseconds since system startup
    attr_reader :uptime
    attr_reader :report
  end
end
